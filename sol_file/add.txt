	[Scanner::next]scanToken Result
	m_currentToken:	--, m_currentLiteral: 
	m_nextToken:	pragma, m_nextLiteral: pragma
	[Scanner::next]scanToken Result
	m_currentToken:	pragma, m_currentLiteral: pragma
	m_nextToken:	Identifier, m_nextLiteral: solidity
[cli::processInput]m_compiler->compile()
[CompilerStack::compile]compile()
-------------[CompilerStack::parse]parse()------------
	[Scanner::next]scanToken Result
	m_currentToken:	Identifier, m_currentLiteral: solidity
	m_nextToken:	pragma, m_nextLiteral: pragma
	[Scanner::next]scanToken Result
	m_currentToken:	pragma, m_currentLiteral: pragma
	m_nextToken:	Identifier, m_nextLiteral: solidity
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	Identifier, m_currentLiteral: solidity
	m_nextToken:	^, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	^, m_currentLiteral: 
	m_nextToken:	Number, m_nextLiteral: 0.5
	[Scanner::next]scanToken Result
	m_currentToken:	Number, m_currentLiteral: 0.5
	m_nextToken:	Number, m_nextLiteral: .0
	[Scanner::next]scanToken Result
	m_currentToken:	Number, m_currentLiteral: .0
	m_nextToken:	;, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	;, m_currentLiteral: 
	m_nextToken:	contract, m_nextLiteral: contract
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	contract, m_currentLiteral: contract
	m_nextToken:	Identifier, m_nextLiteral: TicketSeller
	[Scanner::next]scanToken Result
	m_currentToken:	Identifier, m_currentLiteral: TicketSeller
	m_nextToken:	{, m_nextLiteral: 
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	{, m_currentLiteral: 
	m_nextToken:	uintM, m_nextLiteral: uint256
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	uintM, m_currentLiteral: uint256
	m_nextToken:	Identifier, m_nextLiteral: a
	[Scanner::next]scanToken Result
	m_currentToken:	Identifier, m_currentLiteral: a
	m_nextToken:	;, m_nextLiteral: 
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	;, m_currentLiteral: 
	m_nextToken:	constructor, m_nextLiteral: constructor
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	constructor, m_currentLiteral: constructor
	m_nextToken:	(, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	(, m_currentLiteral: 
	m_nextToken:	), m_nextLiteral: 
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	), m_currentLiteral: 
	m_nextToken:	public, m_nextLiteral: public
	[Scanner::next]scanToken Result
	m_currentToken:	public, m_currentLiteral: public
	m_nextToken:	{, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	{, m_currentLiteral: 
	m_nextToken:	Identifier, m_nextLiteral: a
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	Identifier, m_currentLiteral: a
	m_nextToken:	=, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	=, m_currentLiteral: 
	m_nextToken:	Number, m_nextLiteral: 0
	[Scanner::next]scanToken Result
	m_currentToken:	Number, m_currentLiteral: 0
	m_nextToken:	;, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	;, m_currentLiteral: 
	m_nextToken:	}, m_nextLiteral: 
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	}, m_currentLiteral: 
	m_nextToken:	function, m_nextLiteral: function
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	function, m_currentLiteral: function
	m_nextToken:	Identifier, m_nextLiteral: add
	[Scanner::next]scanToken Result
	m_currentToken:	Identifier, m_currentLiteral: add
	m_nextToken:	(, m_nextLiteral: 
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	(, m_currentLiteral: 
	m_nextToken:	), m_nextLiteral: 
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	), m_currentLiteral: 
	m_nextToken:	public, m_nextLiteral: public
	[Scanner::next]scanToken Result
	m_currentToken:	public, m_currentLiteral: public
	m_nextToken:	{, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	{, m_currentLiteral: 
	m_nextToken:	Identifier, m_nextLiteral: a
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	Identifier, m_currentLiteral: a
	m_nextToken:	+=, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	+=, m_currentLiteral: 
	m_nextToken:	Number, m_nextLiteral: 1
	[Scanner::next]scanToken Result
	m_currentToken:	Number, m_currentLiteral: 1
	m_nextToken:	;, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	;, m_currentLiteral: 
	m_nextToken:	}, m_nextLiteral: 
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	}, m_currentLiteral: 
	m_nextToken:	function, m_nextLiteral: function
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	function, m_currentLiteral: function
	m_nextToken:	Identifier, m_nextLiteral: read
	[Scanner::next]scanToken Result
	m_currentToken:	Identifier, m_currentLiteral: read
	m_nextToken:	(, m_nextLiteral: 
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	(, m_currentLiteral: 
	m_nextToken:	), m_nextLiteral: 
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	), m_currentLiteral: 
	m_nextToken:	public, m_nextLiteral: public
	[Scanner::next]scanToken Result
	m_currentToken:	public, m_currentLiteral: public
	m_nextToken:	view, m_nextLiteral: view
	[Scanner::next]scanToken Result
	m_currentToken:	view, m_currentLiteral: view
	m_nextToken:	returns, m_nextLiteral: returns
	[Scanner::next]scanToken Result
	m_currentToken:	returns, m_currentLiteral: returns
	m_nextToken:	(, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	(, m_currentLiteral: 
	m_nextToken:	uintM, m_nextLiteral: uint256
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	uintM, m_currentLiteral: uint256
	m_nextToken:	), m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	), m_currentLiteral: 
	m_nextToken:	{, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	{, m_currentLiteral: 
	m_nextToken:	return, m_nextLiteral: return
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	return, m_currentLiteral: return
	m_nextToken:	Identifier, m_nextLiteral: a
	[Scanner::next]scanToken Result
	m_currentToken:	Identifier, m_currentLiteral: a
	m_nextToken:	;, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	;, m_currentLiteral: 
	m_nextToken:	}, m_nextLiteral: 
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	}, m_currentLiteral: 
	m_nextToken:	}, m_nextLiteral: 
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	}, m_currentLiteral: 
	m_nextToken:	EOS, m_nextLiteral: 
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	EOS, m_currentLiteral: 
	m_nextToken:	EOS, m_nextLiteral: 
------------[CompilerStack::analyze()]-------------
[SyntaxChecker::checkSyntax]
		SourceUnit&ASTConstVisitor accept
		PragmaDirective&ASTConstVisitor accept
		ContractDefinition&ASTConstVisitor accept
		VariableDeclaration&ASTConstVisitor accept
		ElementaryTypeName&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		ExpressionStatement&ASTConstVisitor accept
		Assignment&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
		Literal&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		ExpressionStatement&ASTConstVisitor accept
		Assignment&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
		Literal&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		VariableDeclaration&ASTConstVisitor accept
		ElementaryTypeName&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		Return&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
[DocStringAnalyser::analyseDocStrings]
		SourceUnit&ASTConstVisitor accept
		PragmaDirective&ASTConstVisitor accept
		ContractDefinition&ASTConstVisitor accept
		VariableDeclaration&ASTConstVisitor accept
		ElementaryTypeName&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		ExpressionStatement&ASTConstVisitor accept
		Assignment&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
		Literal&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		ExpressionStatement&ASTConstVisitor accept
		Assignment&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
		Literal&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		VariableDeclaration&ASTConstVisitor accept
		ElementaryTypeName&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		Return&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
		SourceUnit&ASTVisitor accept
		PragmaDirective&ASTVisitor accept
		ContractDefinition&ASTVisitor accept
		VariableDeclaration&ASTVisitor accept
		ElementaryTypeName&ASTVisitor accept
		FunctionDefinition&ASTVisitor accept
		ParameterList&ASTVisitor accept
		ParameterList&ASTVisitor accept
		Block&ASTVisitor accept
		ExpressionStatement&ASTVisitor accept
		Assignment&ASTVisitor accept
		Identifier&ASTVisitor accept
		Literal&ASTVisitor accept
		FunctionDefinition&ASTVisitor accept
		ParameterList&ASTVisitor accept
		ParameterList&ASTVisitor accept
		Block&ASTVisitor accept
		ExpressionStatement&ASTVisitor accept
		Assignment&ASTVisitor accept
		Identifier&ASTVisitor accept
		Literal&ASTVisitor accept
		FunctionDefinition&ASTVisitor accept
		ParameterList&ASTVisitor accept
		ParameterList&ASTVisitor accept
		VariableDeclaration&ASTVisitor accept
		ElementaryTypeName&ASTVisitor accept
		Block&ASTVisitor accept
		Return&ASTVisitor accept
		Identifier&ASTVisitor accept
		VariableDeclaration&ASTConstVisitor accept
		ElementaryTypeName&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		VariableDeclaration&ASTConstVisitor accept
		ElementaryTypeName&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		VariableDeclaration&ASTConstVisitor accept
		ElementaryTypeName&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		ExpressionStatement&ASTConstVisitor accept
		Assignment&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
		Literal&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		ExpressionStatement&ASTConstVisitor accept
		Assignment&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
		Literal&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		VariableDeclaration&ASTConstVisitor accept
		ElementaryTypeName&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		Return&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
[TypeChecker::checkTypeRequirements]
		ContractDefinition&ASTConstVisitor accept
		VariableDeclaration&ASTConstVisitor accept
		ElementaryTypeName&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		ExpressionStatement&ASTConstVisitor accept
		Assignment&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
		Literal&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		ExpressionStatement&ASTConstVisitor accept
		Assignment&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
		Literal&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		VariableDeclaration&ASTConstVisitor accept
		ElementaryTypeName&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		Return&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
		SourceUnit&ASTConstVisitor accept
		PragmaDirective&ASTConstVisitor accept
		ContractDefinition&ASTConstVisitor accept
		VariableDeclaration&ASTConstVisitor accept
		ElementaryTypeName&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		ExpressionStatement&ASTConstVisitor accept
		Assignment&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
		Literal&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		ExpressionStatement&ASTConstVisitor accept
		Assignment&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
		Literal&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		VariableDeclaration&ASTConstVisitor accept
		ElementaryTypeName&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		Return&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
		SourceUnit&ASTConstVisitor accept
		PragmaDirective&ASTConstVisitor accept
		ContractDefinition&ASTConstVisitor accept
		VariableDeclaration&ASTConstVisitor accept
		ElementaryTypeName&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		ExpressionStatement&ASTConstVisitor accept
		Assignment&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
		Literal&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		ExpressionStatement&ASTConstVisitor accept
		Assignment&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
		Literal&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		VariableDeclaration&ASTConstVisitor accept
		ElementaryTypeName&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		Return&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
		SourceUnit&ASTConstVisitor accept
		PragmaDirective&ASTConstVisitor accept
		ContractDefinition&ASTConstVisitor accept
		VariableDeclaration&ASTConstVisitor accept
		ElementaryTypeName&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		SourceUnit&ASTConstVisitor accept
		PragmaDirective&ASTConstVisitor accept
		ContractDefinition&ASTConstVisitor accept
		VariableDeclaration&ASTConstVisitor accept
		ElementaryTypeName&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		ExpressionStatement&ASTConstVisitor accept
		Assignment&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
		Literal&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		ExpressionStatement&ASTConstVisitor accept
		Assignment&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
		Literal&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		VariableDeclaration&ASTConstVisitor accept
		ElementaryTypeName&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		Return&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
		ContractDefinition&ASTConstVisitor accept
		VariableDeclaration&ASTConstVisitor accept
		ElementaryTypeName&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		ExpressionStatement&ASTConstVisitor accept
		Assignment&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
		Literal&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		ExpressionStatement&ASTConstVisitor accept
		Assignment&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
		Literal&ASTConstVisitor accept
		FunctionDefinition&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		ParameterList&ASTConstVisitor accept
		VariableDeclaration&ASTConstVisitor accept
		ElementaryTypeName&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		Return&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
	parseAndAnalyze succeed
	[Scanner::next]scanToken Result
	m_currentToken:	EOS, m_currentLiteral: 
	m_nextToken:	{, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	{, m_currentLiteral: 
	m_nextToken:	if, m_nextLiteral: if
	[Scanner::next]scanToken Result
	m_currentToken:	if, m_currentLiteral: if
	m_nextToken:	{, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	{, m_currentLiteral: 
	m_nextToken:	if, m_nextLiteral: if
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	if, m_currentLiteral: if
	m_nextToken:	Identifier, m_nextLiteral: condition
	[Scanner::next]scanToken Result
	m_currentToken:	Identifier, m_currentLiteral: condition
	m_nextToken:	{, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	{, m_currentLiteral: 
	m_nextToken:	Identifier, m_nextLiteral: revert
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	Identifier, m_currentLiteral: revert
	m_nextToken:	(, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	(, m_currentLiteral: 
	m_nextToken:	Number, m_nextLiteral: 0
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	Number, m_currentLiteral: 0
	m_nextToken:	,, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	,, m_currentLiteral: 
	m_nextToken:	Number, m_nextLiteral: 0
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	Number, m_currentLiteral: 0
	m_nextToken:	), m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	), m_currentLiteral: 
	m_nextToken:	}, m_nextLiteral: 
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	}, m_currentLiteral: 
	m_nextToken:	}, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	}, m_currentLiteral: 
	m_nextToken:	EOS, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	EOS, m_currentLiteral: 
	m_nextToken:	EOS, m_nextLiteral: 
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	EOS, m_currentLiteral: 
	m_nextToken:	EOS, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	EOS, m_currentLiteral: 
	m_nextToken:	EOS, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	EOS, m_currentLiteral: 
	m_nextToken:	EOS, m_nextLiteral: 
		FunctionDefinition&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		ExpressionStatement&ASTConstVisitor accept
		Assignment&ASTConstVisitor accept
		Literal&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
		FunctionDefinition&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		Return&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a
	[Scanner::next]scanToken Result
	m_currentToken:	EOS, m_currentLiteral: 
	m_nextToken:	{, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	{, m_currentLiteral: 
	m_nextToken:	if, m_nextLiteral: if
	[Scanner::next]scanToken Result
	m_currentToken:	if, m_currentLiteral: if
	m_nextToken:	{, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	{, m_currentLiteral: 
	m_nextToken:	if, m_nextLiteral: if
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	if, m_currentLiteral: if
	m_nextToken:	Identifier, m_nextLiteral: condition
	[Scanner::next]scanToken Result
	m_currentToken:	Identifier, m_currentLiteral: condition
	m_nextToken:	{, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	{, m_currentLiteral: 
	m_nextToken:	Identifier, m_nextLiteral: revert
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	Identifier, m_currentLiteral: revert
	m_nextToken:	(, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	(, m_currentLiteral: 
	m_nextToken:	Number, m_nextLiteral: 0
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	Number, m_currentLiteral: 0
	m_nextToken:	,, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	,, m_currentLiteral: 
	m_nextToken:	Number, m_nextLiteral: 0
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	Number, m_currentLiteral: 0
	m_nextToken:	), m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	), m_currentLiteral: 
	m_nextToken:	}, m_nextLiteral: 
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	}, m_currentLiteral: 
	m_nextToken:	}, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	}, m_currentLiteral: 
	m_nextToken:	EOS, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	EOS, m_currentLiteral: 
	m_nextToken:	EOS, m_nextLiteral: 
	[ParserBase::expectToken]
	[Scanner::next]scanToken Result
	m_currentToken:	EOS, m_currentLiteral: 
	m_nextToken:	EOS, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	EOS, m_currentLiteral: 
	m_nextToken:	EOS, m_nextLiteral: 
	[Scanner::next]scanToken Result
	m_currentToken:	EOS, m_currentLiteral: 
	m_nextToken:	EOS, m_nextLiteral: 
		FunctionDefinition&ASTConstVisitor accept
		Block&ASTConstVisitor accept
		ExpressionStatement&ASTConstVisitor accept
		Assignment&ASTConstVisitor accept
		Literal&ASTConstVisitor accept
		Identifier&ASTConstVisitor accept
			name is a

======= add.sol:TicketSeller =======
Binary: 
6080604052348015600f57600080fd5b506000808190555060d1806100256000396000f3fe6080604052348015600f57600080fd5b506004361060325760003560e01c80634f2be91f14603757806357de26a414603f575b600080fd5b603d605b565b005b6045606d565b6040518082815260200191505060405180910390f35b60016000808282540192505081905550565b6000805490509056fea265627a7a72315820c3e43b1ae3b563bccad935f0759b099c7d9fabaedf820f408c9aa0137ba6135a64736f6c637828302e352e31312d646576656c6f702e323031392e372e32362b636f6d6d69742e62646562396535320058
Contract JSON ABI 
[{"constant":false,"inputs":[],"name":"add","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"read","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"}]
